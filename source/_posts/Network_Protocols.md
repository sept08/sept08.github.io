---
title: 网络协议
layout: post
date: 2017-08-06 14:20:30
tags: protocol
categories: Theory
comments: true
---

https://www.destroyallsoftware.com/compendium/network-protocols?share_key=97d3ba4c24d21147

网络协议栈的神奇之处在于它确实能做成一些似乎不可能的事情：
它能在不稳定的网络上提供稳定的传输，且并不会有多少可检测出的问题；
它能通过平滑地处理来应对将到来的网络拥塞；
它能为上亿的活跃节点提供地址连接；
它也能在一条链路发生故障时，在另一条链路上重建数据报的传递，以应对可能遭到损坏的网络基础设施；
它还能通过调节使深奥的模拟电路硬件适应需求，就好像是在为一根以太网电缆的两端做平衡、调节。
它运行的非常良好以至于用户都不曾听说过，甚至大部分的软件开发者也并不清楚它是如何运行的。

## 网络路由
在模拟电话时代的晚期，打电话意味着你的电话到你朋友的电话之间存在一条**连续的电连接**，
就像是在你们之间拉了一条线似得，当然实际上是没有这样的一条线的，它是通过复杂的交换系统实现的，但理论上讲它确实等价于一条单独的连线。

网络节点过多的情况下都是以这种方式工作的，因为我们无法在想要通信的两台机器之间提供一条不间断的直连路径。

如同救火时水桶在人们排成一行的队列上传递一样，数据在路由器构成的链路上从一个传递到下一个，逐渐接近目的地。
比如在我的个人电脑和Google.com之间彼此相连的众多路由器上，维护着一个描述他们邻接关系的路由表。
当一个要去往Google.com的数据报到达时，会根据路由表进行一次快速查找，然后告诉路由器这个数据报该派发到哪个邻近路由器上，以使它更接近Google。
当然这些数据报都很小，所以链路上的路由器花费几毫秒就能将它们转发。

路由转发可以分解为两个子问题：
1. **寻址**，即数据报要被发往何处？这由IP([网际协议](https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE))控制，
仅根据源主机地址和目的主机地址来传送数据，定义了寻址方式和数据报的封装方式。
IP地址从最普遍IPv4版本开始，仅提供了32位的地址空间，不过目前已经[全部分配完毕](https://blogs.igalia.com/dpino/2017/05/25/ipv4-exhaustion/)，所以再往公网增加节点就需要对已有的IP地址进行重用。
最新的IPv6提供\\(2^{128}\\)个地址（大约\\(10^{38}\\)），不过2017年已有大有20%被分配。

2.  **路由表**，现在我们标定了网络中节点的地址，接下来我们需要知道如何将数据报经过互联网路由到它的目的地。
由于路由发生的很快，所以没有时间让我们为了获取路由信息到一个远程数据库上去查询。
举个例子，Cisco ASR 9922路由器最大容量为每秒160兆位，假设1.5KB的满数据报，在19英寸机架上每秒就要转发13,333,333,333个数据报。
为了更快的进行路由，每个路由器都维护着指向若干IP地址段路径的路由表。当一个新数据报到达某个路由器时，该路由器便会查询自己的路由表，然后告知哪个自己邻近的路由器更接近目的地，随即向该邻近路由器派发，如此转到下个路由器上继续类似的派发。
边际网关协议([BGP](https://en.wikipedia.org/wiki/Border_Gateway_Protocol))的职责便是通过去中心化的方式维护更新不同路由器上路由表的相连关系。

然而仅依据IP和BGP并不能构建一个可用的网络，因为这无法保证数据的可靠传输。
如果某个路由器超载而废弃了一个数据报，我们就需要一种方式能够检测到这种丢包并且请求重传。（充分不必要）

## 分组交换
假设互联网上所有的数据传输都是仅依靠路由器来完成的，那么如果数据量很大会遇到什么情况呢,比如我们要请求一个88.5MB名为[The Birth & Death of JavaScript](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript)的视频？

我们能想到网络方式可能是这样的：将所要请求的88.5MB的文件从web服务上传递到第一个路由器，接着第二个路由器，如此一个接一个直到请求方。但不幸的我要告诉你，这种网络在互联网尺度下是无法工作的，甚至在企事业单位的内网尺度下也都无法工作。

首先，计算机的内存都是有限的，如果一个给定的路由器目前仅有88.4MB可用的缓存空间，那么显然就无法存储88.5MB的视频文件。那么这份数据就会被遗弃，或者更糟的是路由器并不会提示我有数据被遗弃掉了。

其次，单个的计算机节点都是不可靠的，有时路由节点会故障，有时船锚也可能意外地损毁海底光缆，以致离线掉大片网络节点。

由于以上或者更多的其他原因，我们就没法在互联网上一次传递88.5MB的信息，而是将它分解成多个数据报再单独传输，每个数据报大概1,400bytes，所以上面的视频文件将被分解为63,214或更多的数据报来传输。

## 乱序报文
使用抓包工具[Wireshark](https://www.wireshark.org/)来测量视频[The Birth & Death of JavaScript](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript)的实际传输情况，
会看到共接收61,807个数据报，每个大小为1,432bytes，将这两个数相乘得到88.5MB，刚好是我们所传视频的大小。
（这里不包含各种协议增加的额外开销，如果算上，那这个值可能会更高一些）

这次传输是在HTTP协议（一个位于传输控制协议[TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)上层的协议）上完成的，共耗时14秒。平均每秒4,400个数据报，每250微秒一个数据报。在这14秒中，我们总共收到61,807个数据报，其中可能发生过乱序，但最终重组为完整视频文件的样子。

TCP数据报的重组是采用所能想到最简单的方式完成的：每个数据报在它传输时赋予一个序列号，在接收端据此序列号重排数据报。只要他们按序且无缺漏，就认为整个文件传输完成。（实际的TCP序列号并不是简单的自加1的整数，但这在此并不是讨论的重点）

我们是如何知道文件何时传输完成的呢？TCP并未对此提供什么帮助，这是高层协议的职责。例如HTTP响应中包含一个"Content-Length"头字段，来指定响应的byte长度

## 传输窗和慢启动

## 可靠传输

## 物理网络

## 网络与现实世界

## 互联的网络协议栈
