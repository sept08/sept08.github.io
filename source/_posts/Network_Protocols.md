---
title: 网络协议
layout: post
date: 2017-08-06 14:20:30
tags: protocol
categories: Theory
comments: true
---

https://www.destroyallsoftware.com/compendium/network-protocols?share_key=97d3ba4c24d21147

网络协议栈的神奇之处在于它确实能做成一些似乎不可能的事情：
它能在不稳定的网络上提供稳定的传输，且并不会有多少可检测出的问题；
它能通过平滑地处理来应对将到来的网络拥塞；
它能为上亿的活跃节点提供地址连接；
它也能在一条链路发生故障时，在另一条链路上重建数据报的传递，以应对可能遭到损坏的网络基础设施；
它还能通过调节使深奥的模拟电路硬件适应需求，就好像是在为一根以太网电缆的两端做平衡、调节。
它运行的非常良好以至于用户都不曾听说过，甚至大部分的软件开发者也并不清楚它是如何运行的。

## 网络路由
在模拟电话时代的晚期，打电话意味着你的电话到你朋友的电话之间存在一条**连续的电连接**，
就像是在你们之间拉了一条线似得，当然实际上是没有这样的一条线的，它是通过复杂的交换系统实现的，但理论上讲它确实等价于一条单独的连线。

网络节点过多的情况下都是以这种方式工作的，因为我们无法在想要通信的两台机器之间提供一条不间断的直连路径。

如同救火时水桶在人们排成一行的队列上传递一样，数据在路由器构成的链路上从一个传递到下一个，逐渐接近目的地。
比如在我的个人电脑和Google.com之间彼此相连的众多路由器上，维护着一个描述他们邻接关系的路由表。
当一个要去往Google.com的数据报到达时，会根据路由表进行一次快速查找，然后告诉路由器这个数据报该派发到哪个邻近路由器上，以使它更接近Google。
当然这些数据报都很小，所以链路上的路由器花费几毫秒就能将它们转发。

路由转发可以分解为两个子问题：
1. **寻址**，即数据报要被发往何处？这由IP([网际协议](https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE))控制，
仅根据源主机地址和目的主机地址来传送数据，定义了寻址方式和数据报的封装方式。
IP地址从最普遍IPv4版本开始，仅提供了32位的地址空间，不过目前已经[全部分配完毕](https://blogs.igalia.com/dpino/2017/05/25/ipv4-exhaustion/)，所以再往公网增加节点就需要对已有的IP地址进行重用。
最新的IPv6提供\\(2^{128}\\)个地址（大约\\(10^{38}\\)），不过2017年已有大有20%被分配。

2.  **路由表**，现在我们标定了网络中节点的地址，接下来我们需要知道如何将数据报经过互联网路由到它的目的地。
由于路由发生的很快，所以没有时间让我们为了获取路由信息到一个远程数据库上去查询。
举个例子，Cisco ASR 9922路由器最大容量为每秒160兆位，假设1.5KB的满数据报，在19英寸机架上每秒就要转发13,333,333,333个数据报。
为了更快的进行路由，每个路由器都维护着指向若干IP地址段路径的路由表。当一个新数据报到达某个路由器时，该路由器便会查询自己的路由表，然后告知哪个自己邻近的路由器更接近目的地，随即向该邻近路由器派发，如此转到下个路由器上继续类似的派发。
边际网关协议([BGP](https://en.wikipedia.org/wiki/Border_Gateway_Protocol))的职责便是通过去中心化的方式维护更新不同路由器上路由表的相连关系。

然而仅依据IP和BGP并不能构建一个可用的网络，因为这无法保证数据的可靠传输。
如果某个路由器超载而废弃了一个数据报，我们就需要一种方式能够检测到这种丢包并且请求重传。（充分不必要）

## 分组交换
假设互联网上所有的数据传输都是仅依靠路由器来完成的，那么如果数据量很大会遇到什么情况呢,比如我们要请求一个88.5MB名为[The Birth & Death of JavaScript](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript)的视频？

我们能想到网络方式可能是这样的：将所要请求的88.5MB的文件从web服务上传递到第一个路由器，接着第二个路由器，如此一个接一个直到请求方。但不幸的我要告诉你，这种网络在互联网尺度下是无法工作的，甚至在企事业单位的内网尺度下也都无法工作。

首先，计算机的内存都是有限的，如果一个给定的路由器目前仅有88.4MB可用的缓存空间，那么显然就无法存储88.5MB的视频文件。那么这份数据就会被遗弃，或者更糟的是路由器并不会提示我有数据被遗弃掉了。

其次，单个的计算机节点都是不可靠的，有时路由节点会故障，有时船锚也可能意外地损毁海底光缆，以致离线掉大片网络节点。

由于以上或者更多的其他原因，我们就没法在互联网上一次传递88.5MB的信息，而是将它分解成多个数据报再单独传输，每个数据报大概1,400bytes，所以上面的视频文件将被分解为63,214或更多的数据报来传输。

## 乱序报文
使用抓包工具[Wireshark](https://www.wireshark.org/)来测量视频[The Birth & Death of JavaScript](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript)的实际传输情况，
会看到共接收61,807个数据报，每个大小为1,432bytes，将这两个数相乘得到88.5MB，刚好是我们所传视频的大小。
（这里不包含各种协议增加的额外开销，如果算上，那这个值可能会更高一些）

这次传输是在HTTP协议（一个位于传输控制协议[TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)上层的协议）上完成的，共耗时14秒。平均每秒4,400个数据报，每250微秒一个数据报。在这14秒中，我们总共收到61,807个数据报，其中可能发生过乱序，但最终重组为完整视频文件的样子。

TCP数据报的重组是采用所能想到最简单的方式完成的：每个数据报在它传输时赋予一个序列号，在接收端据此序列号重排数据报。只要他们按序且无缺漏，就认为整个文件传输完成。（实际的TCP序列号并不是简单的自加1的整数，但这在此并不是讨论的重点）

我们是如何知道文件何时传输完成的呢？TCP并未对此提供什么帮助，这是更高层协议的职责。例如HTTP响应中包含一个"Content-Length"头字段，用来指定响应的byte长度。客户端首先接收Content-Length值，然后便开始持续读取TCP数据报，并按原有序列进行组装，直到收满Content-Length指定数量的数据报为止。这就是HTTP头比有效响应内容先到的原因之一：我们并不知道有效内容的数据报数量。

我们这里说的客户端，实际是指所有的接收计算机。重组TCP数据报是在其内核中进行的，所以像web浏览器、curl及wget等应用程序无须再手动重组了。但由于内核无法控制HTTP，所以应用程序就必须通过Content-Length来明确到底需要接收多少比特的内容。

有了序列号和重排，我们便可传输大量的比特数据报序列，即便在接收时发生乱序也无妨。可若是在传输过程中出现丢包，使得HTTP响应序列出现间断又该如何？

## 传输窗和慢启动
上面我们在打开[Wireshark](https://www.wireshark.org/)的时候下载了一段视频，如此便可以浏览捕获到的每个数据报。

例如，收到一个序列号为563,321的数据报，如同所有的TCP数据报一样，他有一个“next sequence number”的字段，用于指向随后数据报的序列号。这个数据报“next sequence number”的值为564,753，它是一个ACK（确认数据报）：我的计算机确认收到服务器发送的数据报。在一个新建的连接上，Linux内核会在每发送10个数据报后发送一个ACK包，这个频次可以通过常量`TCP_INIT_CWND`控制（我们可在[Linux内核源码](http://elixir.free-electrons.com/linux/v4.5/source/include/net/tcp.h#L220)中查看次常量）。

（`TCP_INIT_CWND`中的`CWND`代表的是拥塞窗口（congestion window）:一次允许通过的数据量大小）如果网络发生拥塞或者过载，该窗口尺寸将会缩小，导致数据报传输速率降低。

十个数据报大概是14KB，所以我们限制一次传输数据的大小就是14KB。这便是TCP慢启动的一部分：连接从小拥塞窗口开始，如果未发生丢包，接收端将逐渐扩大拥塞窗口，使得在一轮传输中包含更多的数据报。

假设发生了一次丢包，则会使接收端拥塞窗口缩小，导致传输变慢。通过拥塞窗口的自动调节以及一些其他的参数，接收端和发送端之间将保持尽可能快的数据传输速率。

这种速率调整在连接的两端都会发生：一端确认另一端发送的信息，每端维护各自的拥塞窗口大小。不对称的窗口需要协议可以充分利用网络连接不对称的上下行带宽，就像大部分的居民区和移动互联网。

## 可靠传输
计算机节点是不可靠的，那么有不可靠的节点构成的网络将会更加不可靠。在一个大尺度的网络中，故障是正常运行的一部分，必须要进行弥补容错。在数据报网络中，这就意味着重传：就是当接受端收到1号和3号数据报，而未收到2号数据报时，那么它需要向服务器请求重传丢失的数据报。

当每秒要接受上千个数据报时，就像我们上面下载88.5MB的视频文件的例子，故障时很可能会发生的。为了证明这一点，我们回到Wireshark捕获的下载报文

## 物理网络

## 网络与现实世界

## 互联的网络协议栈
